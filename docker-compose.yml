services:
  # ============================================
  # API GATEWAY - NGINX
  # ============================================

  nginx:
    image: nginx:alpine
    container_name: yemma-nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    networks:
      - yemma-network
    depends_on:
      auth:
        condition: service_healthy
      candidate:
        condition: service_healthy
      frontend:
        condition: service_started
      # Les autres services sont optionnels pour nginx
      # - document
      # - search
      # - company
      # - payment
      # - notification
      # - audit
      # - admin
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # ============================================
  # INFRASTRUCTURE
  # ============================================
  
  postgres:
    image: postgres:15-alpine
    container_name: yemma-postgres
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-postgres}
      POSTGRES_DB: ${DB_NAME:-yemma_db}
      # PGDATA défini dans un sous-répertoire pour éviter les conflits
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - yemma-network
    # Port non exposé - les services Docker communiquent via le réseau interne
    # Pour accéder depuis l'extérieur, utilisez: docker-compose exec postgres psql -U postgres -d yemma_db
    # ports:
    #   - "${DB_PORT:-5433}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres} -d ${DB_NAME:-yemma_db}"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: yemma-redis
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis_password}
    volumes:
      - redis_data:/data
    networks:
      - yemma-network
    # Port non exposé car utilisé uniquement par les services Docker internes
    # ports:
    #   - "${REDIS_PORT:-6379}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD:-redis_password}", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  minio:
    image: minio/minio:latest
    container_name: yemma-minio
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin123}
    volumes:
      - minio_data:/data
    networks:
      - yemma-network
    # Ports exposés uniquement pour l'administration (optionnel, peut être retiré)
    # En production, accéder via Nginx reverse proxy
    ports:
      - "${MINIO_API_PORT:-9000}:9000"
      - "${MINIO_CONSOLE_PORT:-9001}:9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    restart: unless-stopped

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: yemma-elasticsearch
    environment:
      # Mode single-node pour le développement
      - discovery.type=single-node
      
      # Désactiver la sécurité SSL/Auth pour faciliter l'intégration locale
      - xpack.security.enabled=false
      - xpack.security.http.ssl.enabled=false
      - xpack.security.transport.ssl.enabled=false
      - xpack.security.enrollment.enabled=false
      
      # Configuration Java
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      
      # Désactiver les warnings de bootstrap
      - bootstrap.memory_lock=false
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - yemma-network
    # Ports exposés uniquement pour l'administration (optionnel, peut être retiré)
    # En production, accéder via Nginx reverse proxy
    ports:
      - "${ELASTICSEARCH_PORT:-9200}:9200"
      - "${ELASTICSEARCH_TRANSPORT_PORT:-9300}:9300"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 300s
    deploy:
      resources:
        limits:
          memory: 1g
    restart: unless-stopped

  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    container_name: yemma-kibana
    environment:
      # Connexion à ElasticSearch
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      
      # Désactiver la sécurité pour correspondre à ElasticSearch
      - xpack.security.enabled=false
      - xpack.encryptedSavedObjects.encryptionKey=minimal-32-character-encryption-key-for-dev
      
      # Configuration du serveur
      - SERVER_NAME=kibana
      - SERVER_HOST=0.0.0.0
      
      # Désactiver les télémetries (optionnel)
      - TELEMETRY_OPTIN=false
    networks:
      - yemma-network
    # Port exposé uniquement pour l'administration (optionnel, peut être retiré)
    # En production, accéder via Nginx reverse proxy
    ports:
      - "${KIBANA_PORT:-5601}:5601"
    depends_on:
      elasticsearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5601/api/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    restart: unless-stopped

  # ============================================
  # BACKEND SERVICES
  # ============================================

  auth:
    build:
      context: ./services
      dockerfile: auth-service/Dockerfile
    container_name: yemma-auth
    environment:
      # Application
      APP_NAME: auth-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # JWT
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      JWT_ACCESS_TOKEN_EXPIRE_MINUTES: ${JWT_ACCESS_TOKEN_EXPIRE_MINUTES:-30}
      
      # OAuth2
      OAUTH2_SECRET_KEY: ${OAUTH2_SECRET_KEY:-your-oauth2-secret-key-change-in-production}
      
      # CORS (format JSON pour les listes Pydantic)
      CORS_ORIGINS: ${CORS_ORIGINS:-["http://localhost:3000","http://localhost:8000","http://localhost"]}
      
      # Redis
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis_password}@redis:6379/0
    volumes:
      - ./services/auth-service:/app
      - ./services/shared:/shared
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    # En production, utiliser uniquement via Nginx Gateway
    ports:
      - "${AUTH_PORT:-8001}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  candidate:
    build:
      context: ./services/candidate
      dockerfile: Dockerfile
    container_name: yemma-candidate
    environment:
      # Application
      APP_NAME: candidate-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # JWT Validation
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      AUTH_SERVICE_URL: http://auth:8000
      
      # Document Service
      DOCUMENT_SERVICE_URL: http://document:8000
      
      # CORS (format JSON pour les listes Pydantic)
      CORS_ORIGINS: ${CORS_ORIGINS:-["http://localhost:3000","http://localhost:8000","http://localhost"]}
      
      # Redis
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis_password}@redis:6379/0
    volumes:
      - ./services/candidate:/app
      - ./services/shared:/shared
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    # En production, utiliser uniquement via Nginx Gateway
    ports:
      - "${CANDIDATE_PORT:-8002}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      auth:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  document:
    build:
      context: ./services/document
      dockerfile: Dockerfile
    container_name: yemma-document
    environment:
      # Application
      APP_NAME: document-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # S3 / MinIO
      S3_ENDPOINT: http://minio:9000
      S3_PUBLIC_ENDPOINT: http://localhost:9000
      S3_ACCESS_KEY: ${MINIO_ROOT_USER:-minioadmin}
      S3_SECRET_KEY: ${MINIO_ROOT_PASSWORD:-minioadmin123}
      S3_BUCKET_NAME: ${S3_BUCKET_NAME:-documents}
      S3_REGION: ${S3_REGION:-us-east-1}
      S3_USE_SSL: ${S3_USE_SSL:-false}
      S3_FORCE_PATH_STYLE: ${S3_FORCE_PATH_STYLE:-true}
      
      # File Upload
      MAX_FILE_SIZE: ${MAX_FILE_SIZE:-10485760}
      ALLOWED_EXTENSIONS: "pdf,jpg,jpeg,png"
      TEMP_LINK_EXPIRE_HOURS: ${TEMP_LINK_EXPIRE_HOURS:-24}
      
      # JWT Validation
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      AUTH_SERVICE_URL: http://auth:8000
      
      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS:-"http://localhost:3000,http://localhost:8000,http://localhost"}
    volumes:
      - ./services/document:/app
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour accès direct (dev) - accès aussi via Nginx Gateway
    ports:
      - "${DOCUMENT_PORT:-8003}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      minio:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  search:
    build:
      context: ./services/search
      dockerfile: Dockerfile
    container_name: yemma-search
    environment:
      # Application
      APP_NAME: search-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # ElasticSearch
      ELASTICSEARCH_HOST: elasticsearch
      ELASTICSEARCH_PORT: 9200
      ELASTICSEARCH_USER: ${ELASTICSEARCH_USER:-}
      ELASTICSEARCH_PASSWORD: ${ELASTICSEARCH_PASSWORD:-}
      ELASTICSEARCH_USE_SSL: ${ELASTICSEARCH_USE_SSL:-false}
      ELASTICSEARCH_VERIFY_CERTS: ${ELASTICSEARCH_VERIFY_CERTS:-false}
      ELASTICSEARCH_INDEX_NAME: ${ELASTICSEARCH_INDEX_NAME:-certified_candidates}
      
      # RabbitMQ
      RABBITMQ_HOST: rabbitmq
      RABBITMQ_PORT: 5672
      RABBITMQ_USER: ${RABBITMQ_USER:-rabbitmq}
      RABBITMQ_PASSWORD: ${RABBITMQ_PASSWORD:-rabbitmq_password}
      RABBITMQ_VHOST: ${RABBITMQ_VHOST:-/}
      
      # Service URLs
      CANDIDATE_SERVICE_URL: http://candidate:8000
      ADMIN_SERVICE_URL: http://admin:8000
      AUTH_SERVICE_URL: http://auth:8000
      PAYMENT_SERVICE_URL: http://payment:8000
      AUDIT_SERVICE_URL: http://audit:8000
      COMPANY_SERVICE_URL: http://company:8000

      # JWT Validation (pour le fallback si AUTH_SERVICE_URL ne répond pas)
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}

      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS:-["http://localhost:3000","http://localhost:8000","http://localhost"]}
    volumes:
      - ./services/search:/app
      - ./services/shared:/shared
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    # En production, utiliser uniquement via Nginx Gateway
    ports:
      - "${SEARCH_PORT:-8004}:8000"
    depends_on:
      elasticsearch:
        condition: service_healthy
      auth:
        condition: service_healthy
      candidate:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  admin:
    build:
      context: ./services/admin
      dockerfile: Dockerfile
    container_name: yemma-admin
    environment:
      # Application
      APP_NAME: admin-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Service URLs
      CANDIDATE_SERVICE_URL: http://candidate:8000
      SEARCH_SERVICE_URL: http://search:8000
      NOTIFICATION_SERVICE_URL: http://notification:8000
      
      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    volumes:
      - ./services/admin:/app
      - ./services/shared:/shared
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    # En production, utiliser uniquement via Nginx Gateway
    ports:
      - "${ADMIN_PORT:-8009}:8000"
    depends_on:
      candidate:
        condition: service_healthy
      # search peut être unhealthy, on démarre quand même
      # search:
      #   condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  company:
    build:
      context: ./services/company
      dockerfile: Dockerfile
    container_name: yemma-company
    environment:
      # Application
      APP_NAME: company-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # JWT Validation
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      AUTH_SERVICE_URL: http://auth:8000
      
      # Invitation
      INVITATION_TOKEN_EXPIRE_DAYS: ${INVITATION_TOKEN_EXPIRE_DAYS:-7}
      INVITATION_SECRET_KEY: ${INVITATION_SECRET_KEY:-your-invitation-secret-key}
      
      # Service URLs
      SEARCH_SERVICE_URL: http://search:8000
      SUBSCRIPTION_SERVICE_URL: http://subscription:8000
      NOTIFICATION_SERVICE_URL: http://notification:8000
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      
      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000,http://localhost}
    volumes:
      - ./services/company:/app
      - ./services/shared:/shared
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    # En production, utiliser uniquement via Nginx Gateway
    ports:
      - "${COMPANY_PORT:-8005}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      auth:
        condition: service_healthy
      # search peut être unhealthy, on démarre quand même
      # search:
      #   condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  payment:
    build:
      context: ./services/payment
      dockerfile: Dockerfile
    container_name: yemma-payment
    environment:
      # Application
      APP_NAME: payment-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # Stripe
      STRIPE_SECRET_KEY: ${STRIPE_SECRET_KEY:-sk_test_your_stripe_secret_key}
      STRIPE_PUBLISHABLE_KEY: ${STRIPE_PUBLISHABLE_KEY:-pk_test_your_stripe_publishable_key}
      STRIPE_WEBHOOK_SECRET: ${STRIPE_WEBHOOK_SECRET:-whsec_your_webhook_secret}
      STRIPE_CURRENCY: ${STRIPE_CURRENCY:-eur}
      
      # Service URLs
      COMPANY_SERVICE_URL: http://company:8000
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      
      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    volumes:
      - ./services/payment:/app
      - ./services/shared:/shared
      - /app/__pycache__
    networks:
      - yemma-network
    # Port non exposé - accès via Nginx Gateway
    # ports:
    #   - "${PAYMENT_PORT:-8006}:8006"
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:$$PORT/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  notification:
    build:
      context: ./services/notification
      dockerfile: Dockerfile
    container_name: yemma-notification
    environment:
      # Application
      APP_NAME: notification-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      PORT: ${NOTIFICATION_PORT:-8000}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # Email Provider
      EMAIL_PROVIDER: ${EMAIL_PROVIDER:-fastapi_mail}
      
      # SMTP
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-noreply.yemma@gmail.com}
      SMTP_PASSWORD: ${SMTP_PASSWORD:-mszr byaj gzmp scfq}
      SMTP_USE_TLS: ${SMTP_USE_TLS:-true}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL:-noreply.yemma@gmail.com}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME:-Yemma Solutions}
      
      # SendGrid
      SENDGRID_API_KEY: ${SENDGRID_API_KEY:-}
      SENDGRID_FROM_EMAIL: ${SENDGRID_FROM_EMAIL:-noreply@yemma.com}
      SENDGRID_FROM_NAME: ${SENDGRID_FROM_NAME:-Yemma Solutions}
      
      # Mailgun
      MAILGUN_API_KEY: ${MAILGUN_API_KEY:-}
      MAILGUN_DOMAIN: ${MAILGUN_DOMAIN:-}
      MAILGUN_FROM_EMAIL: ${MAILGUN_FROM_EMAIL:-noreply@yemma.com}
      MAILGUN_FROM_NAME: ${MAILGUN_FROM_NAME:-Yemma Solutions}
      
      # Task Queue (background_tasks ou celery)
      TASK_QUEUE: ${TASK_QUEUE:-background_tasks}
      
      # Redis (pour Celery)
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      
      # Frontend
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      
      # CORS (format string séparée par virgules)
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    volumes:
      - ./services/notification:/app
      - /app/__pycache__
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    ports:
      - "${NOTIFICATION_PORT:-8007}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "sh", "-c", "curl -f http://localhost:$$PORT/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  notification-worker:
    build:
      context: ./services/notification
      dockerfile: Dockerfile
    container_name: yemma-notification-worker
    environment:
      # Application
      APP_NAME: notification-worker
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # Email Provider
      EMAIL_PROVIDER: ${EMAIL_PROVIDER:-fastapi_mail}
      
      # SMTP
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-noreply.yemma@gmail.com}
      SMTP_PASSWORD: ${SMTP_PASSWORD:-mszr byaj gzmp scfq}
      SMTP_USE_TLS: ${SMTP_USE_TLS:-true}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL:-noreply.yemma@gmail.com}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME:-Yemma Solutions}
      
      # SendGrid
      SENDGRID_API_KEY: ${SENDGRID_API_KEY:-}
      SENDGRID_FROM_EMAIL: ${SENDGRID_FROM_EMAIL:-noreply@yemma.com}
      SENDGRID_FROM_NAME: ${SENDGRID_FROM_NAME:-Yemma Solutions}
      
      # Redis (pour Celery)
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      
      # Frontend
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      
      # Task Queue
      TASK_QUEUE: celery
    volumes:
      - ./services/notification:/app
      - /app/__pycache__
    networks:
      - yemma-network
    command: celery -A app.infrastructure.celery_app worker --loglevel=info --concurrency=2 --queues=notifications
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  audit:
    build:
      context: ./services/audit
      dockerfile: Dockerfile
    container_name: yemma-audit
    environment:
      # Application
      APP_NAME: audit-service
      APP_ENV: ${APP_ENV:-development}
      DEBUG: ${DEBUG:-true}
      
      # Database
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      
      # CORS
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    volumes:
      - ./services/audit:/app
      - /app/__pycache__
    networks:
      - yemma-network
    # Port non exposé - accès via Nginx Gateway
    # ports:
    #   - "${AUDIT_PORT:-8008}:8000"
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  # ============================================
  # FRONTEND
  # ============================================

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: yemma-frontend
    environment:
      # Variables d'environnement pour Vite (préfixe VITE_)
      # Utilise des chemins relatifs vides pour passer par nginx (chemins dans api.js)
      # Si besoin d'utiliser nginx directement, définir: VITE_API_BASE_URL=http://nginx
      VITE_API_BASE_URL: ${VITE_API_BASE_URL:-}
      VITE_AUTH_API_URL: ${VITE_AUTH_API_URL:-}
      VITE_CANDIDATE_API_URL: ${VITE_CANDIDATE_API_URL:-}
      VITE_DOCUMENT_API_URL: ${VITE_DOCUMENT_API_URL:-}
      VITE_SEARCH_API_URL: ${VITE_SEARCH_API_URL:-}
      VITE_COMPANY_API_URL: ${VITE_COMPANY_API_URL:-}
      VITE_PAYMENT_API_URL: ${VITE_PAYMENT_API_URL:-}
      VITE_NOTIFICATION_API_URL: ${VITE_NOTIFICATION_API_URL:-}
      VITE_AUDIT_API_URL: ${VITE_AUDIT_API_URL:-}
      VITE_ADMIN_API_URL: ${VITE_ADMIN_API_URL:-}
    volumes:
      - ./frontend:/app
      - /app/node_modules
    networks:
      - yemma-network
    # Port exposé pour le développement (accès direct)
    # En production, utiliser uniquement via Nginx Gateway
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    depends_on:
      - auth
      - candidate
    restart: unless-stopped

# ============================================
# NETWORKS
# ============================================

networks:
  yemma-network:
    name: yemma-network
    driver: bridge

# ============================================
# VOLUMES
# ============================================

volumes:
  postgres_data:
    name: yemma-postgres-data
  redis_data:
    name: yemma-redis-data
  minio_data:
    name: yemma-minio-data
  elasticsearch_data:
    name: yemma-elasticsearch-data

