# Docker Compose for Production (Hostinger deployment)
# Usage: docker-compose up -d
#
# En cas d'erreur "container name already in use" sur Hostinger :
#   1. SSH sur le VPS
#   2. Exécuter : ./scripts/cleanup-hostinger.sh
#   3. Relancer le déploiement

services:
  # ============================================
  # API GATEWAY - NGINX
  # ============================================

  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    container_name: yemma-nginx
    ports:
      # Hostinger : port 80 souvent utilisé par Apache/cPanel → 8080 par défaut
      - "${NGINX_HTTP_PORT:-8080}:80"
      - "${NGINX_HTTPS_PORT:-8443}:443"
    networks:
      - yemma-network
    depends_on:
      auth:
        condition: service_healthy
      candidate:
        condition: service_healthy
      frontend:
        condition: service_started
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # ============================================
  # INFRASTRUCTURE
  # ============================================

  postgres:
    # postgres:15 (Debian) au lieu de alpine : support des locales (évite "no usable system locales were found")
    image: postgres:15
    container_name: yemma-postgres
    environment:
      POSTGRES_USER: ${DB_USER:-postgres}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-postgres}
      POSTGRES_DB: ${DB_NAME:-yemma_db}
      PGDATA: /var/lib/postgresql/data/pgdata
      LANG: en_US.UTF-8
      LC_ALL: en_US.UTF-8
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - yemma-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER:-postgres} -d ${DB_NAME:-yemma_db}"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: yemma-redis
    # Warning "Memory overcommit must be enabled" : exécuter sur le VPS (root)
    #   sudo sysctl vm.overcommit_memory=1
    # ou : sudo ./scripts/fix-redis-overcommit.sh
    command: redis-server --requirepass ${REDIS_PASSWORD:-redis_password}
    volumes:
      - redis_data:/data
    networks:
      - yemma-network
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD:-redis_password}", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  minio:
    image: minio/minio:latest
    container_name: yemma-minio
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER:-minioadmin}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD:-minioadmin123}
    volumes:
      - minio_data:/data
    networks:
      - yemma-network
    ports:
      - "${MINIO_API_PORT:-9000}:9000"
      - "${MINIO_CONSOLE_PORT:-9001}:9001"
    # Pas de healthcheck : l'image MinIO récente n'inclut pas curl/wget/mc
    # Le warning "Host local has more than 0 drives" est normal en single-node
    restart: unless-stopped

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: yemma-elasticsearch
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
      - xpack.security.http.ssl.enabled=false
      - xpack.security.transport.ssl.enabled=false
      - xpack.security.enrollment.enabled=false
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - bootstrap.memory_lock=false
      # Réduire l'empreinte mémoire sur VPS limité
      - xpack.ml.enabled=false
      - xpack.monitoring.collection.enabled=false
      - cluster.routing.allocation.disk.threshold_enabled=false
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - yemma-network
    ports:
      - "${ELASTICSEARCH_PORT:-9200}:9200"
      - "${ELASTICSEARCH_TRANSPORT_PORT:-9300}:9300"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 300s
    deploy:
      resources:
        limits:
          memory: 1g
    restart: unless-stopped

  kibana:
    image: docker.elastic.co/kibana/kibana:8.11.0
    container_name: yemma-kibana
    # Pas de volume ./kibana/kibana.yml : Hostinger résout mal les chemins relatifs (mount error)
    # Configuration via variables d'environnement uniquement
    environment:
      - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
      - SERVER_NAME=kibana
      - SERVER_HOST=0.0.0.0
      - TELEMETRY_OPTIN=false
      - XPACK_SECURITY_ENABLED=false
      - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=minimal-32-character-encryption-key-for-dev
      - XPACK_SECURITY_ENCRYPTIONKEY=minimal-32-char-security-encryption-key
      - XPACK_REPORTING_ENCRYPTIONKEY=minimal-32-char-reporting-encryption-key
    networks:
      - yemma-network
    ports:
      - "${KIBANA_PORT:-5601}:5601"
    depends_on:
      elasticsearch:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:5601/api/status || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 60s
    restart: unless-stopped

  # ============================================
  # BACKEND SERVICES
  # ============================================

  auth:
    build:
      context: ./services
      dockerfile: auth-service/Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-auth
    environment:
      APP_NAME: auth-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      JWT_ACCESS_TOKEN_EXPIRE_MINUTES: ${JWT_ACCESS_TOKEN_EXPIRE_MINUTES:-30}
      OAUTH2_SECRET_KEY: ${OAUTH2_SECRET_KEY:-your-oauth2-secret-key-change-in-production}
      CORS_ORIGINS: ${CORS_ORIGINS:-["http://localhost:3000","http://localhost:8000","http://localhost","http://127.0.0.1:3000","http://127.0.0.1:8000","http://127.0.0.1"]}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis_password}@redis:6379/0
    # NO VOLUMES - code is baked into the image
    networks:
      - yemma-network
    ports:
      - "${AUTH_PORT:-8001}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  candidate:
    build:
      context: ./services
      dockerfile: candidate/Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-candidate
    environment:
      APP_NAME: candidate-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app:/shared
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      AUTH_SERVICE_URL: http://auth:8000
      DOCUMENT_SERVICE_URL: http://document:8000
      CORS_ORIGINS: ${CORS_ORIGINS:-["http://localhost:3000","http://localhost:8000","http://localhost","http://127.0.0.1:3000","http://127.0.0.1:8000","http://127.0.0.1"]}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      REDIS_URL: redis://:${REDIS_PASSWORD:-redis_password}@redis:6379/0
    networks:
      - yemma-network
    ports:
      - "${CANDIDATE_PORT:-8002}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      auth:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  document:
    build:
      context: ./services/document
      dockerfile: Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-document
    environment:
      APP_NAME: document-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      S3_ENDPOINT: http://minio:9000
      S3_PUBLIC_ENDPOINT: http://localhost:9000
      S3_ACCESS_KEY: ${MINIO_ROOT_USER:-minioadmin}
      S3_SECRET_KEY: ${MINIO_ROOT_PASSWORD:-minioadmin123}
      S3_BUCKET_NAME: ${S3_BUCKET_NAME:-documents}
      S3_REGION: ${S3_REGION:-us-east-1}
      S3_USE_SSL: ${S3_USE_SSL:-false}
      S3_FORCE_PATH_STYLE: ${S3_FORCE_PATH_STYLE:-true}
      MAX_FILE_SIZE: ${MAX_FILE_SIZE:-10485760}
      ALLOWED_EXTENSIONS: "pdf,jpg,jpeg,png"
      TEMP_LINK_EXPIRE_HOURS: ${TEMP_LINK_EXPIRE_HOURS:-24}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      AUTH_SERVICE_URL: http://auth:8000
      CORS_ORIGINS: ${CORS_ORIGINS:-"http://localhost:3000,http://localhost:8000,http://localhost,http://127.0.0.1:3000,http://127.0.0.1:8000,http://127.0.0.1"}
    networks:
      - yemma-network
    ports:
      - "${DOCUMENT_PORT:-8003}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      minio:
        condition: service_started
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  search:
    build:
      context: ./services/search
      dockerfile: Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-search
    environment:
      APP_NAME: search-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      ELASTICSEARCH_HOST: elasticsearch
      ELASTICSEARCH_PORT: 9200
      ELASTICSEARCH_USER: ${ELASTICSEARCH_USER:-}
      ELASTICSEARCH_PASSWORD: ${ELASTICSEARCH_PASSWORD:-}
      ELASTICSEARCH_USE_SSL: ${ELASTICSEARCH_USE_SSL:-false}
      ELASTICSEARCH_VERIFY_CERTS: ${ELASTICSEARCH_VERIFY_CERTS:-false}
      ELASTICSEARCH_INDEX_NAME: ${ELASTICSEARCH_INDEX_NAME:-certified_candidates}
      RABBITMQ_HOST: rabbitmq
      RABBITMQ_PORT: 5672
      RABBITMQ_USER: ${RABBITMQ_USER:-rabbitmq}
      RABBITMQ_PASSWORD: ${RABBITMQ_PASSWORD:-rabbitmq_password}
      RABBITMQ_VHOST: ${RABBITMQ_VHOST:-/}
      CANDIDATE_SERVICE_URL: http://candidate:8000
      ADMIN_SERVICE_URL: http://admin:8000
      AUTH_SERVICE_URL: http://auth:8000
      PAYMENT_SERVICE_URL: http://payment:8000
      AUDIT_SERVICE_URL: http://audit:8000
      COMPANY_SERVICE_URL: http://company:8000
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      CORS_ORIGINS: ${CORS_ORIGINS:-["http://localhost:3000","http://localhost:8000","http://localhost"]}
    networks:
      - yemma-network
    ports:
      - "${SEARCH_PORT:-8004}:8000"
    depends_on:
      elasticsearch:
        condition: service_healthy
      auth:
        condition: service_healthy
      candidate:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  admin:
    build:
      context: ./services
      dockerfile: admin/Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-admin
    environment:
      APP_NAME: admin-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app:/shared
      DEBUG: ${DEBUG:-false}
      CANDIDATE_SERVICE_URL: http://candidate:8000
      SEARCH_SERVICE_URL: http://search:8000
      NOTIFICATION_SERVICE_URL: http://notification:8000
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    networks:
      - yemma-network
    ports:
      - "${ADMIN_PORT:-8009}:8000"
    depends_on:
      candidate:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  company:
    build:
      context: ./services
      dockerfile: company/Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-company
    environment:
      APP_NAME: company-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app:/shared
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      JWT_SECRET_KEY: ${JWT_SECRET_KEY:-your-super-secret-jwt-key-change-in-production}
      JWT_ALGORITHM: ${JWT_ALGORITHM:-HS256}
      AUTH_SERVICE_URL: http://auth:8000
      INVITATION_TOKEN_EXPIRE_DAYS: ${INVITATION_TOKEN_EXPIRE_DAYS:-7}
      INVITATION_SECRET_KEY: ${INVITATION_SECRET_KEY:-your-invitation-secret-key}
      SEARCH_SERVICE_URL: http://search:8000
      SUBSCRIPTION_SERVICE_URL: http://subscription:8000
      NOTIFICATION_SERVICE_URL: http://notification:8000
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000,http://localhost}
    networks:
      - yemma-network
    ports:
      - "${COMPANY_PORT:-8005}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      auth:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  payment:
    build:
      context: ./services/payment
      dockerfile: Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-payment
    environment:
      APP_NAME: payment-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      STRIPE_SECRET_KEY: ${STRIPE_SECRET_KEY:-sk_test_your_stripe_secret_key}
      STRIPE_PUBLISHABLE_KEY: ${STRIPE_PUBLISHABLE_KEY:-pk_test_your_stripe_publishable_key}
      STRIPE_WEBHOOK_SECRET: ${STRIPE_WEBHOOK_SECRET:-whsec_your_webhook_secret}
      STRIPE_CURRENCY: ${STRIPE_CURRENCY:-eur}
      COMPANY_SERVICE_URL: http://company:8000
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    networks:
      - yemma-network
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  notification:
    build:
      context: ./services/notification
      dockerfile: Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-notification
    environment:
      APP_NAME: notification-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      PORT: ${NOTIFICATION_PORT:-8000}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      EMAIL_PROVIDER: ${EMAIL_PROVIDER:-fastapi_mail}
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-noreply.yemma@gmail.com}
      SMTP_PASSWORD: ${SMTP_PASSWORD:-}
      SMTP_USE_TLS: ${SMTP_USE_TLS:-true}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL:-noreply.yemma@gmail.com}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME:-Yemma Solutions}
      SENDGRID_API_KEY: ${SENDGRID_API_KEY:-}
      SENDGRID_FROM_EMAIL: ${SENDGRID_FROM_EMAIL:-noreply@yemma.com}
      SENDGRID_FROM_NAME: ${SENDGRID_FROM_NAME:-Yemma Solutions}
      MAILGUN_API_KEY: ${MAILGUN_API_KEY:-}
      MAILGUN_DOMAIN: ${MAILGUN_DOMAIN:-}
      MAILGUN_FROM_EMAIL: ${MAILGUN_FROM_EMAIL:-noreply@yemma.com}
      MAILGUN_FROM_NAME: ${MAILGUN_FROM_NAME:-Yemma Solutions}
      TASK_QUEUE: ${TASK_QUEUE:-background_tasks}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    networks:
      - yemma-network
    ports:
      - "${NOTIFICATION_PORT:-8007}:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  notification-worker:
    build:
      context: ./services/notification
      dockerfile: Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-notification-worker
    environment:
      APP_NAME: notification-worker
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      EMAIL_PROVIDER: ${EMAIL_PROVIDER:-fastapi_mail}
      SMTP_HOST: ${SMTP_HOST:-smtp.gmail.com}
      SMTP_PORT: ${SMTP_PORT:-587}
      SMTP_USER: ${SMTP_USER:-noreply.yemma@gmail.com}
      SMTP_PASSWORD: ${SMTP_PASSWORD:-}
      SMTP_USE_TLS: ${SMTP_USE_TLS:-true}
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL:-noreply.yemma@gmail.com}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME:-Yemma Solutions}
      SENDGRID_API_KEY: ${SENDGRID_API_KEY:-}
      SENDGRID_FROM_EMAIL: ${SENDGRID_FROM_EMAIL:-noreply@yemma.com}
      SENDGRID_FROM_NAME: ${SENDGRID_FROM_NAME:-Yemma Solutions}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD:-redis_password}
      FRONTEND_URL: ${FRONTEND_URL:-http://localhost:3000}
      TASK_QUEUE: celery
    networks:
      - yemma-network
    command: sh -c "cd /app && export PYTHONPATH=/app && exec python -m celery -A app.infrastructure.celery_app worker --loglevel=info --concurrency=2 --queues=notifications"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  audit:
    build:
      context: ./services/audit
      dockerfile: Dockerfile
      args:
        - APP_ENV=production
    container_name: yemma-audit
    environment:
      APP_NAME: audit-service
      APP_ENV: ${APP_ENV:-production}
      PYTHONPATH: /app
      DEBUG: ${DEBUG:-false}
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: ${DB_USER:-postgres}
      DB_PASSWORD: ${DB_PASSWORD:-postgres}
      DB_NAME: ${DB_NAME:-yemma_db}
      DATABASE_URL: postgresql+asyncpg://${DB_USER:-postgres}:${DB_PASSWORD:-postgres}@postgres:5432/${DB_NAME:-yemma_db}
      CORS_ORIGINS: ${CORS_ORIGINS:-http://localhost:3000,http://localhost:8000}
    networks:
      - yemma-network
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 180s
    restart: unless-stopped

  # ============================================
  # FRONTEND
  # ============================================

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: production
    container_name: yemma-frontend
    networks:
      - yemma-network
    ports:
      - "${FRONTEND_PORT:-3000}:3000"
    depends_on:
      - auth
      - candidate
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

# ============================================
# NETWORKS
# ============================================

networks:
  yemma-network:
    name: yemma-network
    driver: bridge

# ============================================
# VOLUMES
# ============================================

volumes:
  postgres_data:
    name: yemma-postgres-data
  redis_data:
    name: yemma-redis-data
  minio_data:
    name: yemma-minio-data
  elasticsearch_data:
    name: yemma-elasticsearch-data
